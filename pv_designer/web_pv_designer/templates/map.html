{% extends "base.html" %}

{% block content %}
<head>
  <title>Draw on Map</title>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDvX9ndMncH71GBqL-w0wOW9tyPbhgXPlQ&libraries=drawing,places"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
  <style>
    #map {
      height: 600px;
      width: 60%;
    }
    #actions {
      margin-top: 10px;
    }
    #searchInput {
      width: 300px;
      padding: 5px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Photovoltaic calculator</h1>
  <input id="searchInput" type="text" placeholder="Search for an address...">
  <div id="map"></div>
  <div id="actions">
    <button onclick="deleteShape()">Delete</button>
    <button onclick="calculateArea()">Calculate Area</button>
    <div id="areaDisplay"></div>
  </div>
  <script>
    var map;
    var drawingManager;
    var selectedShape;
    var shapes = [];

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 50, lng: 14 },
        zoom: 15,
      });

      drawingManager = new google.maps.drawing.DrawingManager({
        drawingControl: true,
        drawingControlOptions: {
          position: google.maps.ControlPosition.TOP_CENTER,
          drawingModes: [
            google.maps.drawing.OverlayType.POLYGON,
            google.maps.drawing.OverlayType.RECTANGLE,
          ]
        },
        polygonOptions: {
          editable: true,
          draggable: true,
          strokeColor: '#0033ff',
        },
        rectangleOptions: {
          editable: true,
          draggable: true,
          strokeColor: '#0033ff',
        }
      });

      drawingManager.setMap(map);

      google.maps.event.addListener(drawingManager, 'overlaycomplete', function(event) {
        var shape = event.overlay;
        shapes.push(shape);
        google.maps.event.addListener(shape, 'click', function() {
          selectShape(shape);
        });
        drawingManager.setDrawingMode(null);
        selectShape(shape);
      });

      google.maps.event.addListener(drawingManager, 'drawingmode_changed', clearSelection);

      google.maps.event.addListener(map, 'click', clearSelection);
      searchBoxInit(map)
    }

    function clearSelection() {
      if (selectedShape) {
        selectedShape.setEditable(false);
        selectedShape.setDraggable(false);
        selectedShape = null;
      }
    }

    function selectShape(shape) {
      clearSelection();
      selectedShape = shape;
      shape.setEditable(true);
      shape.setDraggable(true);
    }

    function deleteShape() {
      if (selectedShape) {
        selectedShape.setMap(null); // Remove shape from the map
        var index = shapes.indexOf(selectedShape);
        if (index !== -1) {
          shapes.splice(index, 1); // Remove shape from the shapes array
        }
        selectedShape = null;
      }
    }

    function calculateArea() {
      area_string = "Plocha:" + '<br>';
      sum = 0;
      i = 0;
      //for each shape in shapes
      console.log(shapes[0]);
      shapes.forEach(function(shape) {
        i++;
        if (shape instanceof google.maps.Polygon) {
          var area = google.maps.geometry.spherical.computeArea(shape.getPath());
          area_string += i + ': ' + area.toFixed(2) + " m^2" + '<br>';
          sum += area;
        }
        else if (shape instanceof google.maps.Rectangle) {
          var bounds = shape.getBounds();
          var area = google.maps.geometry.spherical.computeArea(shape.getBounds());
          area_string += i + ': ' + area.toFixed(2) + " m^2" + '<br>';
            sum += area;
        }
      });
        document.getElementById("areaDisplay").innerHTML = area_string + "<br> Celkova plocha: " + sum.toFixed(2) + " m^2";
    }

    function searchBoxInit(map){
      // Create the search box and link it to the UI element.
      const input = document.getElementById("searchInput");
      const searchBox = new google.maps.places.SearchBox(input);

      // Bias the SearchBox results towards current map's viewport.
      map.addListener("bounds_changed", () => {
        searchBox.setBounds(map.getBounds());
      });
      let markers = [];
      // Listen for the event fired when the user selects a prediction and retrieve
      // more details for that place.
      searchBox.addListener("places_changed", () => {
        const places = searchBox.getPlaces();

        if (places.length == 0) {
          return;
        }

        // Clear out the old markers.
        markers.forEach((marker) => {
          marker.setMap(null);
        });
        markers = [];

        // For each place, get the icon, name and location.
        const bounds = new google.maps.LatLngBounds();

        places.forEach((place) => {
          if (!place.geometry || !place.geometry.location) {
            console.log("Returned place contains no geometry");
            return;
          }

          const icon = {
            url: place.icon,
            size: new google.maps.Size(71, 71),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(17, 34),
            scaledSize: new google.maps.Size(25, 25),
          };

          // Create a marker for each place.
          markers.push(
                  new google.maps.Marker({
                    map,
                    icon,
                    title: place.name,
                    position: place.geometry.location,
                  }),
          );
          if (place.geometry.viewport) {
            // Only geocodes have viewport.
            bounds.union(place.geometry.viewport);
          } else {
            bounds.extend(place.geometry.location);
          }
        });
        map.fitBounds(bounds);
      });
    }
    // Initialize the map
    initMap();

  </script>
</body>
</html>

{% endblock %}